<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Golf Mayhem: Deck of Chaos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Chewy&family=Fredoka:wght@400;600&display=swap" rel="stylesheet">

  <!-- GSAP for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 1.25rem 1rem 2.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      background:
        radial-gradient(circle at 0% 0%, #ff9a62 0, transparent 45%),
        radial-gradient(circle at 100% 0%, #9b5bff 0, transparent 45%),
        radial-gradient(circle at 50% 100%, #32e6b7 0, transparent 50%),
        linear-gradient(135deg, #130323, #05010a);
      font-family: "Fredoka", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff7ff;
      overflow-x: hidden;
      overflow-y: auto;
    }

    h1 {
      font-family: "Chewy", system-ui, sans-serif;
      font-size: 2.1rem;
      margin: 0;
      text-align: center;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #ffe66d;
      text-shadow:
        0 2px 0 #140518,
        0 6px 14px rgba(0, 0, 0, 0.8);
    }

    .subtitle {
      margin-top: 0.2rem;
      font-size: 0.9rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      text-align: center;
      opacity: 0.9;
    }

    .top-bar {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.6rem;
      font-size: 0.78rem;
    }

    .top-bar button {
      padding: 0.4rem 1.1rem;
      border-radius: 999px;
      border: 0;
      background: rgba(0, 0, 0, 0.3);
      color: #fdf7ff;
      font-family: inherit;
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.2);
    }

    .top-bar button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.3);
    }

    .filters-panel {
      margin-top: 0.6rem;
      width: min(480px, 100%);
      border-radius: 16px;
      background: rgba(6, 0, 24, 0.88);
      border: 1px solid rgba(255,255,255,0.16);
      padding: 0.7rem 0.9rem 0.85rem;
      display: none;
      backdrop-filter: blur(12px);
    }

    .filters-panel.open {
      display: block;
    }

    .filters-title {
      font-size: 0.8rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      margin-bottom: 0.45rem;
      opacity: 0.95;
    }

    .filter-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem 0.8rem;
      align-items: center;
    }

    .filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.78rem;
      padding: 0.18rem 0.6rem;
      border-radius: 999px;
      background: rgba(10, 8, 40, 0.9);
      border: 1px solid rgba(255,255,255,0.14);
    }

    .filter-chip input {
      width: 14px;
      height: 14px;
    }

    .filters-note {
      margin-top: 0.45rem;
      font-size: 0.75rem; /* slightly larger */
      opacity: 0.8;
    }

    .buttons {
      margin-top: 0.9rem;
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    button.main-btn {
      padding: 0.7rem 1.7rem;
      border-radius: 999px;
      border: 0;
      background: linear-gradient(135deg, #ffd166, #ff4b5c);
      color: #311117;
      font-family: "Fredoka", system-ui, sans-serif;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      font-size: 0.8rem;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      box-shadow:
        0 8px 18px rgba(0,0,0,0.9),
        0 0 10px rgba(255,255,255,0.25);
      position: relative;
      overflow: hidden;
    }

    button.main-btn.secondary {
      background: linear-gradient(135deg, #9ad0ff, #7f5dff);
      color: #110821;
    }

    button.main-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow:
        0 5px 12px rgba(0,0,0,0.9),
        0 0 6px rgba(255,255,255,0.15);
    }

    .card-area {
      margin-top: 1.4rem;
      width: 100%;
      display: flex;
      justify-content: center;
      perspective: 1200px;
    }

    /* Base modifier card: light teal, dark text */
    .card {
      position: relative;
      width: min(320px, 92vw);
      aspect-ratio: 2.5 / 3.75;
      border-radius: 18px;
      background:
        radial-gradient(circle at 0 0, #ffffff 0, transparent 55%),
        radial-gradient(circle at 100% 100%, #e3f6ff 0, transparent 55%),
        #f4fbff;
      border: 3px solid #0288d1;
      box-shadow:
        0 12px 30px rgba(0,0,0,0.7),
        0 0 0 2px rgba(0,0,0,0.45);
      padding: 16px 14px 14px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transform-origin: center;
      transition:
        box-shadow 0.16s ease,
        background 0.16s ease,
        border-color 0.16s ease;
      cursor: pointer;
      backface-visibility: hidden;
      transform-style: preserve-3d;
      overflow: hidden;
    }

    .card:hover {
      box-shadow:
        0 18px 36px rgba(0,0,0,0.85),
        0 0 0 2px rgba(0,0,0,0.5);
    }

    .card-title {
      font-family: "Chewy", system-ui, sans-serif;
      font-size: 1.4rem;
      color: #045b78;
      text-shadow: 0 2px 0 #bde7ff;
      padding: 0 0.4rem;
    }

    .card-text {
      font-size: 1.02rem;
      color: #143544;
      line-height: 1.45;
    }

    /* Mini game card styling: purple/pink with sparkles + shimmer */
    .card.mini-game {
      background:
        radial-gradient(circle at 0 0, #f3c5ff 0, transparent 55%),
        radial-gradient(circle at 100% 100%, #c3c8ff 0, transparent 55%),
        #4a265f;
      border-color: #9b5bff;
    }

    .card.mini-game .card-title {
      color: #ffe6ff;
      text-shadow: 0 2px 0 #6f1ad1;
    }

    .card.mini-game .card-text {
      color: #fbe8ff;
    }

    .card.mini-game::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        radial-gradient(circle, rgba(255,255,255,0.9) 0, transparent 55%),
        radial-gradient(circle, rgba(0,245,212,0.7) 0, transparent 60%),
        radial-gradient(circle, rgba(155,91,255,0.6) 0, transparent 55%);
      background-size: 18px 18px, 26px 26px, 22px 22px;
      background-position: 10% 20%, 70% 40%, 30% 80%;
      mix-blend-mode: screen;
      opacity: 0.0;
      pointer-events: none;
      animation: miniSparkles 2.4s ease-in-out 0.1s infinite alternate;
    }

    @keyframes miniSparkles {
      0% {
        opacity: 0.15;
        transform: translate3d(-2px, -2px, 0);
      }
      100% {
        opacity: 0.4;
        transform: translate3d(2px, 2px, 0);
      }
    }

    .card.mini-game::after {
      content: "";
      position: absolute;
      top: -40%;
      left: -60%;
      width: 220%;
      height: 180%;
      background: linear-gradient(
        120deg,
        rgba(255,255,255,0.0) 0%,
        rgba(255,255,255,0.35) 45%,
        rgba(255,255,255,0.0) 80%
      );
      opacity: 0;
      transform: translateX(-40%);
      pointer-events: none;
      animation: miniShimmer 1.3s ease-out 0.18s 1 forwards;
    }

    @keyframes miniShimmer {
      0% {
        opacity: 0;
        transform: translateX(-40%);
      }
      30% {
        opacity: 0.9;
      }
      100% {
        opacity: 0;
        transform: translateX(40%);
      }
    }

    /* Super modifier cards: orange/red + foil + burst */
    .card.super-modifier {
      background:
        radial-gradient(circle at 0 0, #ffe0bf 0, transparent 55%),
        radial-gradient(circle at 100% 100%, #ff9a7b 0, transparent 55%),
        #6b1a0e;
      border-color: #ff7043;
      box-shadow:
        0 16px 36px rgba(0,0,0,0.85),
        0 0 0 2px rgba(120,0,0,0.6);
    }

    .card.super-modifier .card-title {
      color: #fff3e0;
      text-shadow: 0 2px 0 #bf360c;
    }

    .card.super-modifier .card-text {
      color: #ffe8dc;
    }

    .card.super-modifier::before {
      content: "";
      position: absolute;
      inset: -20%;
      background:
        radial-gradient(circle, rgba(255,255,255,0.3) 0, transparent 55%),
        radial-gradient(circle at 20% 20%, rgba(255,183,77,0.35) 0, transparent 55%),
        radial-gradient(circle at 80% 80%, rgba(255,138,101,0.35) 0, transparent 55%);
      opacity: 0.0;
      pointer-events: none;
      mix-blend-mode: screen;
      animation: superBurst 0.65s ease-out 0.1s 1 forwards;
    }

    @keyframes superBurst {
      0% {
        opacity: 0;
        transform: scale(0.9);
      }
      40% {
        opacity: 0.75;
        transform: scale(1.03);
      }
      100% {
        opacity: 0.1;
        transform: scale(1.08);
      }
    }

    .card.super-modifier::after {
      content: "";
      position: absolute;
      top: -40%;
      left: -70%;
      width: 240%;
      height: 200%;
      background: linear-gradient(
        115deg,
        rgba(255,255,255,0.0) 0%,
        rgba(255,255,255,0.3) 20%,
        rgba(255,224,178,0.75) 40%,
        rgba(255,255,255,0.3) 60%,
        rgba(255,255,255,0.0) 100%
      );
      mix-blend-mode: screen;
      opacity: 0;
      pointer-events: none;
      animation: superFoil 1.2s ease-out 0.2s 1 forwards;
    }

    @keyframes superFoil {
      0% {
        opacity: 0;
        transform: translateX(-40%);
      }
      35% {
        opacity: 0.95;
      }
      100% {
        opacity: 0;
        transform: translateX(40%);
      }
    }

    .card-header {
      text-align: center;
    }

    .card-label {
      font-size: 0.78rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #7ab9ff; /* readable light blue */
      opacity: 0.96;
      margin-bottom: 0.3rem;
    }

    .card.mini-game .card-label {
      color: #f3e5ff;
    }

    .card.super-modifier .card-label {
      color: #ffccbc;
    }

    .card-divider {
      height: 4px;
      width: 70%;
      background: linear-gradient(to right, #4fd9ff, #0288d1);
      margin: 0.6rem auto 0.7rem;
      border-radius: 99px;
    }

    .card.mini-game .card-divider {
      background: linear-gradient(to right, #bf94ff, #ff7ad8);
    }

    .card.super-modifier .card-divider {
      background: linear-gradient(to right, #ffca28, #ff7043);
    }

    .card-body {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0 4px;
      max-height: 60%;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .card-footer {
      margin-top: 0.45rem;
      min-height: 0.5rem;
    }

    .status {
      margin-top: 0.7rem;
      font-size: 0.84rem; /* slightly larger */
      opacity: 0.9;
      text-align: center;
      min-height: 1.3rem;
    }

    @media (max-width: 420px) {
      .card-text {
        font-size: 0.96rem;
      }
    }
/* Intro "How to Play" card variant */
.card.intro {
  background:
    radial-gradient(circle at 0 0, #ffffff 0, transparent 55%),
    radial-gradient(circle at 100% 100%, #c5ffe5 0, transparent 55%),
    #e0fff4;
  border-color: #1abc9c;
}

/* Slightly different title color on intro card (optional) */
.card.intro .card-title {
  color: #0b6b5c;
  text-shadow: 0 2px 0 #bdf7e6;
}

/* When the label is empty (intro card), hide it and tighten spacing */
.card-label.is-empty {
  display: none;
  margin-bottom: 0;
}

/* Tighter spacing between paragraphs on the how-to card */
.card-text p {
  margin: 0.35rem 0;
}

    #confettiCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .app-footer {
      margin-top: 0.4rem;
      max-width: 540px;
      width: 100%;
      text-align: center;
      font-size: 0.72rem;
      line-height: 1.4;
      opacity: 0.85;
    }

    .app-footer a {
      color: #ffd166;
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    .app-footer a:hover {
      opacity: 0.95;
    }
  </style>
</head>
<body>
  <h1>Mini Golf Mayhem</h1>
  <div class="subtitle">Deck of Chaos</div>

  <div class="top-bar">
    <button id="toggleFiltersBtn">Filters & Deck Options</button>
  </div>

  <div class="filters-panel" id="filtersPanel">
    <div class="filters-title">Filter by chaos type</div>
    <div class="filter-grid">
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="movement" checked>
        <span>Movement / Stance</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="mechanics" checked>
        <span>Shot Mechanics</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="voice" checked>
        <span>Voice / Performance</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="social" checked>
        <span>Social</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="puppet" checked>
        <span>Puppets</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="mini-game" checked>
        <span>Mini Games</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="super" checked>
        <span>Super Modifiers</span>
      </label>
    </div>
    <div class="filters-note">
      Unchecked categories are excluded from the deck. Shuffle resets the deck based on your current filter choices.
    </div>
  </div>

  <div class="buttons">
    <button class="main-btn" id="drawButton">Draw Card</button>
    <button class="main-btn secondary" id="shuffleButton">Shuffle Deck</button>
  </div>

  <div class="card-area">
    <div class="card" id="card">
      <div class="card-header">
        <div class="card-label" id="cardTypeLabel">Modifier</div>
        <div class="card-title" id="cardTitle">How to Play</div>
        <div class="card-divider"></div>
      </div>
      <div class="card-body">
        <div class="card-text" id="cardText">
          <!-- Starter text will be injected by JS -->
        </div>
      </div>
      <div class="card-footer"></div>
    </div>
  </div>

  <canvas id="confettiCanvas"></canvas>
  <div class="status" id="status"></div>

  <div class="app-footer">
    Fan-made tool · <a
      href="https://docs.google.com/forms/d/e/1FAIpQLSfcNcxnaL6A8oWO0cXT9sW6OQjXGq4Ip4tGaeFTsb9-3m5ZRg/viewform?usp=dialog"
      target="_blank"
      rel="noopener"
    >
      Info/Feedback/Contact
    </a>
  </div>

  <script>
    const SHEET_CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vSM17xNjd3IrbpPKTcPbImDp6eG4ZUGgVXj7QsJmZon4NzIvywm-IJ4rwMZ1eW1jNW--NHvQGWOtPzg/pub?gid=0&single=true&output=csv";

const DEFAULT_TITLE = "How to Play";
const DEFAULT_TEXT_HTML = `
  <p><strong>At the start of each hole</strong>, tap the card or “Draw Card” to reveal a chaos modifier.</p>
  <p>It applies to <strong>everyone’s first shot only</strong> on that hole, unless the card says otherwise.</p>
  <p><strong>Mini Game</strong> and <strong>Super Modifier</strong> cards add extra rules. <strong>Mini Games award Immunity Tokens</strong>—spend one to ignore any single modifier later.</p>
`;

    let fullCards = [];
    let deck = [];
    let discardPile = [];

    const cardEl = document.getElementById("card");
    const cardTypeLabel = document.getElementById("cardTypeLabel");
    const cardTitleEl = document.getElementById("cardTitle");
    const cardTextEl = document.getElementById("cardText");
    const statusEl = document.getElementById("status");
    const drawButton = document.getElementById("drawButton");
    const shuffleButton = document.getElementById("shuffleButton");
    const toggleFiltersBtn = document.getElementById("toggleFiltersBtn");
    const filtersPanel = document.getElementById("filtersPanel");
    const confettiCanvas = document.getElementById("confettiCanvas");
    const confettiCtx = confettiCanvas.getContext("2d");

    function resizeConfettiCanvas() {
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
    }
    resizeConfettiCanvas();
    window.addEventListener("resize", resizeConfettiCanvas);

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function getInactiveCategories() {
      const inputs = document.querySelectorAll('input[name="categoryFilter"]');
      const inactive = [];
      inputs.forEach(input => {
        if (!input.checked) inactive.push(input.value);
      });
      return inactive;
    }

    function updateStatus(message = "") {
      const remaining = deck.length;
      const discarded = discardPile.length;
      const info = `Cards remaining: ${remaining} • Discard pile: ${discarded}`;
      statusEl.textContent = message ? `${message}  ${info}` : info;
    }

    function isSpecialCard(card) {
      if (!card) return false;
      const isMiniGame = card.type === "miniGame";
      const cats = Array.isArray(card.categories) ? card.categories : [];
      const isSuperCategory = cats.includes("super");
      const name = typeof card.name === "string" ? card.name : "";
      const isSuperName = name.startsWith("Super Modifier");
      return isMiniGame || isSuperCategory || isSuperName;
    }

    function buildDeck(showMessage = true) {
      if (!fullCards.length) {
        statusEl.textContent = "Deck is still loading...";
        return;
      }

      const inactiveCats = getInactiveCategories();
      let source = fullCards.filter(card =>
        !inactiveCats.length ||
        card.categories.every(cat => !inactiveCats.includes(cat))
      );

      deck = [];
      discardPile = [];

      if (!source.length) {
        statusEl.textContent =
          "No cards match the current filters. Adjust filters to rebuild the deck.";
        return;
      }

      shuffleArray(source);

      const hasSpecial = source.some(isSpecialCard);
      const hasNormal = source.some(card => !isSpecialCard(card));

      if (!hasSpecial || !hasNormal) {
        deck = [...source].reverse();
        if (showMessage) updateStatus("Deck shuffled. Ready to draw.");
        else updateStatus();
        return;
      }

      let order = [...source];

      // Rule 1: first drawn card shouldn't be special if a normal exists.
      if (isSpecialCard(order[0])) {
        const swapIndex = order.findIndex((c, idx) => idx > 0 && !isSpecialCard(c));
        if (swapIndex !== -1) {
          [order[0], order[swapIndex]] = [order[swapIndex], order[0]];
        }
      }

      // Rule 2: avoid consecutive specials when possible.
      for (let i = 1; i < order.length; i++) {
        if (isSpecialCard(order[i]) && isSpecialCard(order[i - 1])) {
          const swapIndex = order.findIndex((c, idx) => idx > i && !isSpecialCard(c));
          if (swapIndex !== -1) {
            [order[i], order[swapIndex]] = [order[swapIndex], order[i]];
          }
        }
      }

      deck = order.slice().reverse();

      if (showMessage) updateStatus("Deck shuffled. Ready to draw.");
      else updateStatus();
    }

    function drawCard() {
      if (!deck.length) {
        updateStatus("The deck is empty. Tap Shuffle Deck to start a new cycle.");
        return;
      }
      const card = deck.pop();
      discardPile.push(card);
      showCard(card);
      updateStatus();
    }

    // Confetti
    let confettiParticles = [];
    let confettiAnimating = false;

    function launchConfetti(kind) {
      const isMini = kind === "miniGame";
      const isSuper = kind === "super";
      if (!isMini && !isSuper) return;

      const baseCount = isMini ? 70 : 90;
      const colors = isMini
        ? ["#00f5d4", "#9b5bff", "#ff99e5", "#ffffff"]
        : ["#ffca28", "#ff4081", "#40c4ff", "#ffffff"];

      confettiParticles = [];
      for (let i = 0; i < baseCount; i++) {
        confettiParticles.push({
          x: Math.random() * confettiCanvas.width,
          y: -10 - Math.random() * 40,
          radius: (isMini ? 2.5 : 3.5) + Math.random() * (isMini ? 2 : 3),
          color: colors[Math.floor(Math.random() * colors.length)],
          vx: -2 + Math.random() * 4,
          vy: 2 + Math.random() * 3.2,
          rotation: Math.random() * Math.PI * 2,
          vr: -0.2 + Math.random() * 0.4,
          square: !isMini && Math.random() < 0.35
        });
      }

      if (!confettiAnimating) {
        confettiAnimating = true;
        const start = performance.now();
        const duration = isMini ? 1400 : 1700;

        function frame(now) {
          const elapsed = now - start;
          confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

          confettiParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05;
            p.rotation += p.vr;

            confettiCtx.save();
            confettiCtx.translate(p.x, p.y);
            confettiCtx.rotate(p.rotation);
            confettiCtx.fillStyle = p.color;

            if (p.square) {
              const size = p.radius * 1.4;
              confettiCtx.fillRect(-size / 2, -size / 2, size, size);
            } else {
              confettiCtx.beginPath();
              confettiCtx.ellipse(0, 0, p.radius, p.radius * 0.6, 0, 0, Math.PI * 2);
              confettiCtx.fill();
            }

            confettiCtx.restore();
          });

          if (elapsed < duration) {
            requestAnimationFrame(frame);
          } else {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            confettiAnimating = false;
          }
        }

        requestAnimationFrame(frame);
      }
    }

function resetCardFace() {
  cardEl.classList.remove("mini-game", "super-modifier");
  cardEl.classList.add("intro");        // intro look

  cardTypeLabel.textContent = "";
  cardTypeLabel.classList.add("is-empty");

  cardTitleEl.textContent = DEFAULT_TITLE;
  cardTextEl.innerHTML = DEFAULT_TEXT_HTML;
}

    function resetCardTransform() {
      if (!window.gsap) return;
      gsap.set(cardEl, {
        x: 0,
        y: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        scale: 1,
        opacity: 1
      });
    }

    function animateShuffleAndReset() {
      if (!window.gsap) {
        resetCardFace();
        return;
      }

      gsap.killTweensOf(cardEl);

      const tl = gsap.timeline();
      tl.to(cardEl, {
        x: -12,
        rotationZ: -3,
        duration: 0.06,
        ease: "sine.inOut"
      })
        .to(cardEl, {
          x: 12,
          rotationZ: 3,
          duration: 0.06,
          ease: "sine.inOut",
          repeat: 4,
          yoyo: true
        })
        .to(cardEl, {
          x: 0,
          rotationZ: 0,
          duration: 0.12,
          ease: "power1.out",
          onComplete: resetCardFace
        });
    }

function applyCardStylesAndText(card) {
  cardEl.classList.remove("mini-game", "super-modifier", "intro");
  cardTypeLabel.classList.remove("is-empty");

      const isMiniGame = card.type === "miniGame";
      const name = typeof card.name === "string" ? card.name : "";
      const cats = Array.isArray(card.categories) ? card.categories : [];
      const isSuper = name.startsWith("Super Modifier") || cats.includes("super");

      if (isMiniGame) {
        cardEl.classList.add("mini-game");
      } else if (isSuper) {
        cardEl.classList.add("super-modifier");
      }

      if (isMiniGame) {
        cardTypeLabel.textContent = "Mini Game";
      } else if (isSuper) {
        cardTypeLabel.textContent = "Super Modifier";
      } else {
        cardTypeLabel.textContent = "Modifier";
      }

      cardTitleEl.textContent = card.name || "(Unnamed card)";
      cardTextEl.textContent = card.text || "";
    }

    // specialType: null | "miniGame" | "super"
    function animDropFromCameraCard(specialType) {
      if (!window.gsap) return;

      gsap.killTweensOf(cardEl);
      resetCardTransform();

      const tl = gsap.timeline();

      // Drop in
      tl.fromTo(
        cardEl,
        {
          scale: 1.16,
          y: -30,
          opacity: 0.0
        },
        {
          scale: 1.02,
          y: 4,
          opacity: 1,
          duration: 0.26,
          ease: "power2.out"
        }
      );

      // Settle
      tl.to(cardEl, {
        scale: 1,
        y: 0,
        duration: 0.14,
        ease: "power1.out"
      });

      if (specialType) {
        tl.add(() => launchConfetti(specialType));

        if (specialType === "miniGame") {
          tl.to(cardEl, {
            rotationZ: 2.0,
            duration: 0.08,
            yoyo: true,
            repeat: 3,
            ease: "sine.inOut"
          }).to(cardEl, {
            rotationZ: 0,
            duration: 0.12,
            ease: "power1.out"
          });
        } else if (specialType === "super") {
          tl.to(cardEl, {
            rotationZ: 3.0,
            scale: 1.02,
            duration: 0.08,
            yoyo: true,
            repeat: 4,
            ease: "sine.inOut"
          }).to(cardEl, {
            rotationZ: 0,
            scale: 1,
            duration: 0.12,
            ease: "power1.out"
          });
        }
      }
    }

    function showCard(card) {
      applyCardStylesAndText(card);

      let specialType = null;
      if (isSpecialCard(card)) {
        specialType = card.type === "miniGame" ? "miniGame" : "super";
      }

      animDropFromCameraCard(specialType);
    }

    function parseCsv(text) {
      const rows = [];
      let row = [];
      let cell = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];

        if (inQuotes) {
          if (ch === '"') {
            if (text[i + 1] === '"') {
              cell += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            cell += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === ",") {
            row.push(cell);
            cell = "";
          } else if (ch === "\n") {
            row.push(cell);
            rows.push(row);
            row = [];
            cell = "";
          } else if (ch === "\r") {
            // ignore
          } else {
            cell += ch;
          }
        }
      }

      if (cell !== "" || row.length) {
        row.push(cell);
        rows.push(row);
      }

      return rows;
    }

    async function loadCardsFromSheet() {
      statusEl.textContent = "Loading deck from sheet...";
      deck = [];
      discardPile = [];
      try {
        const res = await fetch(SHEET_CSV_URL);
        if (!res.ok) throw new Error("Network error");
        const text = await res.text();
        const rows = parseCsv(text);
        if (!rows.length) {
          statusEl.textContent = "No data found in sheet.";
          return;
        }

        const header = rows[0].map(h => h.trim().toLowerCase());
        const nameIdx = header.indexOf("name");
        const typeIdx = header.indexOf("type");
        const catIdx = header.indexOf("categories");
        const textIdx = header.indexOf("text");

        const cards = [];
        for (let i = 1; i < rows.length; i++) {
          const r = rows[i];
          if (!r || r.every(c => !c || !c.trim())) continue;

          const rawName = (r[nameIdx] || "").trim();
          const rawType = (r[typeIdx] || "modifier").trim();
          const rawCats = (r[catIdx] || "").trim();
          const rawText = (r[textIdx] || "").trim();

          const type =
            rawType.toLowerCase() === "minigame" ? "miniGame" : "modifier";

          let categories = rawCats
            ? rawCats.split(/[;|]/).map(c => c.trim()).filter(Boolean)
            : [];

          if (rawName.startsWith("Super Modifier") && !categories.includes("super")) {
            categories.push("super");
          }

          cards.push({
            name: rawName,
            type,
            categories,
            text: rawText
          });
        }

        fullCards = cards;
        buildDeck(false);
        resetCardFace();
        updateStatus("Deck loaded. Ready to draw.");
      } catch (err) {
        console.error("Error loading sheet", err);
        statusEl.textContent = "Could not load deck from sheet.";
      }
    }

    drawButton.addEventListener("click", drawCard);
    shuffleButton.addEventListener("click", () => {
      buildDeck();
      animateShuffleAndReset();
    });
    cardEl.addEventListener("click", drawCard);

    toggleFiltersBtn.addEventListener("click", () => {
      filtersPanel.classList.toggle("open");
    });

    document
      .querySelectorAll('input[name="categoryFilter"]')
      .forEach(input => {
        input.addEventListener("change", () => {
          buildDeck(false);
        });
      });

    // Initialize default text and load data
    resetCardFace();
    loadCardsFromSheet();
  </script>
</body>
</html>
