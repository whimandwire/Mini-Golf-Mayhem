<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Golf Mayhem: Deck of Chaos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Chewy&family=Fredoka:wght@400;600&display=swap" rel="stylesheet">

  <!-- GSAP for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 1.25rem 1rem 2.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      background:
        radial-gradient(circle at 0% 0%, #ff9a62 0, transparent 45%),
        radial-gradient(circle at 100% 0%, #9b5bff 0, transparent 45%),
        radial-gradient(circle at 50% 100%, #32e6b7 0, transparent 50%),
        linear-gradient(135deg, #130323, #05010a);
      font-family: "Fredoka", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff7ff;
      overflow: hidden;
    }

    h1 {
      font-family: "Chewy", system-ui, sans-serif;
      font-size: 2.1rem;
      margin: 0;
      text-align: center;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #ffe66d;
      text-shadow:
        0 2px 0 #140518,
        0 6px 14px rgba(0, 0, 0, 0.8);
    }

    .subtitle {
      margin-top: 0.2rem;
      font-size: 0.9rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      text-align: center;
      opacity: 0.9;
    }

    .top-bar {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.6rem;
      font-size: 0.78rem;
    }

    .top-bar button {
      padding: 0.4rem 1.1rem;
      border-radius: 999px;
      border: 0;
      background: rgba(0, 0, 0, 0.3);
      color: #fdf7ff;
      font-family: inherit;
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.2);
    }

    .top-bar button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.3);
    }

    .filters-panel {
      margin-top: 0.6rem;
      width: min(480px, 100%);
      border-radius: 16px;
      background: rgba(6, 0, 24, 0.88);
      border: 1px solid rgba(255,255,255,0.16);
      padding: 0.7rem 0.9rem 0.85rem;
      display: none;
      backdrop-filter: blur(12px);
    }

    .filters-panel.open {
      display: block;
    }

    .filters-title {
      font-size: 0.8rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      margin-bottom: 0.45rem;
      opacity: 0.95;
    }

    .filter-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem 0.8rem;
      align-items: center;
    }

    .filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.78rem;
      padding: 0.18rem 0.6rem;
      border-radius: 999px;
      background: rgba(10, 8, 40, 0.9);
      border: 1px solid rgba(255,255,255,0.14);
    }

    .filter-chip input {
      width: 14px;
      height: 14px;
    }

    .filters-note {
      margin-top: 0.45rem;
      font-size: 0.7rem;
      opacity: 0.78;
    }

    .buttons {
      margin-top: 0.9rem;
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    button.main-btn {
      padding: 0.7rem 1.7rem;
      border-radius: 999px;
      border: 0;
      background: linear-gradient(135deg, #ffd166, #ff4b5c);
      color: #311117;
      font-family: "Fredoka", system-ui, sans-serif;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      font-size: 0.8rem;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      box-shadow:
        0 8px 18px rgba(0,0,0,0.9),
        0 0 10px rgba(255,255,255,0.25);
      position: relative;
      overflow: hidden;
    }

    button.main-btn.secondary {
      background: linear-gradient(135deg, #9ad0ff, #7f5dff);
      color: #110821;
    }

    button.main-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow:
        0 5px 12px rgba(0,0,0,0.9),
        0 0 6px rgba(255,255,255,0.15);
    }

    .card-area {
      margin-top: 1.4rem;
      width: 100%;
      display: flex;
      justify-content: center;
      perspective: 1200px;
    }

    .card {
      width: min(320px, 92vw);
      aspect-ratio: 2.5 / 3.75;
      border-radius: 18px;
      background:
        radial-gradient(circle at 0 0, #ffe9b8 0, transparent 55%),
        radial-gradient(circle at 100% 100%, #ffc1d8 0, transparent 55%),
        #fff7e5;
      border: 3px solid #c0181b;
      box-shadow:
        0 12px 30px rgba(0,0,0,0.7),
        0 0 0 2px rgba(0,0,0,0.45);
      padding: 16px 14px 14px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transform-origin: center;
      transition: transform 0.16s ease, box-shadow 0.16s ease, background 0.16s ease, border-color 0.16s ease;
      cursor: pointer;
      backface-visibility: hidden;
      transform-style: preserve-3d;
    }

    .card:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow:
        0 18px 36px rgba(0,0,0,0.85),
        0 0 0 2px rgba(0,0,0,0.5);
    }

    .card.mini-game {
      background:
        radial-gradient(circle at 0 0, #f5d4ff 0, transparent 55%),
        radial-gradient(circle at 100% 100%, #d1e1ff 0, transparent 55%),
        #fff0fb;
      border-color: #7f1dff;
    }

    .card.super-modifier {
      background:
        radial-gradient(circle at 0 0, #ffe4df 0, transparent 55%),
        radial-gradient(circle at 100% 100%, #ffb3b3 0, transparent 55%),
        #ffe0e0;
      border-color: #ff1744;
      box-shadow:
        0 14px 32px rgba(0,0,0,0.75),
        0 0 0 2px rgba(120,0,0,0.6);
    }

    .card.chaos-glow {
      animation: chaosGlow 0.8s ease-in-out 0s 2 alternate;
    }

    @keyframes chaosGlow {
      0% {
        box-shadow:
          0 14px 32px rgba(0,0,0,0.75),
          0 0 12px rgba(255,255,255,0.5),
          0 0 30px rgba(255, 64, 129, 0.6);
        transform: translateY(-2px) scale(1.03) rotate(-1.5deg);
      }
      100% {
        box-shadow:
          0 10px 26px rgba(0,0,0,0.6),
          0 0 14px rgba(144, 202, 249, 0.7),
          0 0 36px rgba(103, 58, 183, 0.7);
        transform: translateY(0) scale(1.01) rotate(1.5deg);
      }
    }

    .card.draw-anim {
      animation: cardPop 0.28s cubic-bezier(0.2, 1.4, 0.3, 1);
    }

    @keyframes cardPop {
      0% { transform: translateY(10px) scale(0.95); opacity: 0; }
      70% { transform: translateY(-2px) scale(1.03); opacity: 1; }
      100% { transform: translateY(0) scale(1); opacity: 1; }
    }

    .card-header {
      text-align: center;
    }

    .card-label {
      font-size: 0.72rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: #b20d30;
      opacity: 0.95;
      margin-bottom: 0.3rem;
    }

    .card.mini-game .card-label {
      color: #6f1ad1;
    }

    .card.super-modifier .card-label {
      color: #b00020;
    }

    .card-title {
      font-family: "Chewy", system-ui, sans-serif;
      font-size: 1.4rem;
      color: #b31317;
      text-shadow: 0 2px 0 #ffe6b8;
      padding: 0 0.4rem;
    }

    .card.mini-game .card-title {
      color: #6f1ad1;
      text-shadow: 0 2px 0 #f7e4ff;
    }

    .card.super-modifier .card-title {
      color: #c00024;
      text-shadow: 0 2px 0 #ffe0e0;
    }

    .card-divider {
      height: 4px;
      width: 70%;
      background: linear-gradient(to right, #ffdc6e, #ff4b5c);
      margin: 0.6rem auto 0.7rem;
      border-radius: 99px;
    }

    .card.mini-game .card-divider {
      background: linear-gradient(to right, #bf94ff, #ff7ad8);
    }

    .card.super-modifier .card-divider {
      background: linear-gradient(to right, #ff8a80, #ff1744);
    }

    .card-body {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0 4px;
      max-height: 60%;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .card-text {
      font-size: 1.02rem;
      color: #4b2220;
      line-height: 1.45;
    }

    .card.mini-game .card-text {
      color: #4b2050;
    }

    .card.super-modifier .card-text {
      color: #4b1014;
    }

    .card-footer {
      margin-top: 0.45rem;
      min-height: 0.5rem;
    }

    .status {
      margin-top: 0.7rem;
      font-size: 0.78rem;
      opacity: 0.9;
      text-align: center;
      min-height: 1.3rem;
    }

    @media (max-width: 420px) {
      .card-text {
        font-size: 0.96rem;
      }
    }

    #confettiCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <h1>Mini Golf Mayhem</h1>
  <div class="subtitle">Deck of Chaos</div>

  <div class="top-bar">
    <button id="toggleFiltersBtn">Filters & Deck Options</button>
  </div>

  <div class="filters-panel" id="filtersPanel">
    <div class="filters-title">Filter by chaos type</div>
    <div class="filter-grid">
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="movement" checked>
        <span>Movement / Stance</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="mechanics" checked>
        <span>Shot Mechanics</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="voice" checked>
        <span>Voice / Performance</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="social" checked>
        <span>Social</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="puppet" checked>
        <span>Puppets</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="mini-game" checked>
        <span>Mini Games</span>
      </label>
      <label class="filter-chip">
        <input type="checkbox" name="categoryFilter" value="super" checked>
        <span>Super Modifiers</span>
      </label>
    </div>
    <div class="filters-note">
      Unchecked categories are excluded from the deck. Shuffle resets the deck based on your current filter choices.
    </div>
  </div>

  <div class="buttons">
    <button class="main-btn" id="drawButton">Draw Card</button>
    <button class="main-btn secondary" id="shuffleButton">Shuffle Deck</button>
  </div>

  <div class="card-area">
    <div class="card" id="card">
      <div class="card-header">
        <div class="card-label" id="cardTypeLabel">Shared Modifier</div>
        <div class="card-title" id="cardTitle">Tap the card or “Draw Card”</div>
        <div class="card-divider"></div>
      </div>
      <div class="card-body">
        <div class="card-text" id="cardText">
          At the start of each hole, draw a card and apply the chaos to everyone’s first shot.
          Mini game and super modifier cards add special rules when they appear.
        </div>
      </div>
      <div class="card-footer"></div>
    </div>
  </div>

  <canvas id="confettiCanvas"></canvas>
  <div class="status" id="status"></div>

  <script>
    const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSM17xNjd3IrbpPKTcPbImDp6eG4ZUGgVXj7QsJmZon4NzIvywm-IJ4rwMZ1eW1jNW--NHvQGWOtPzg/pub?gid=0&single=true&output=csv";

    let fullCards = [];
    let deck = [];
    let discardPile = [];

    const cardEl = document.getElementById("card");
    const cardTypeLabel = document.getElementById("cardTypeLabel");
    const cardTitleEl = document.getElementById("cardTitle");
    const cardTextEl = document.getElementById("cardText");
    const statusEl = document.getElementById("status");
    const drawButton = document.getElementById("drawButton");
    const shuffleButton = document.getElementById("shuffleButton");
    const toggleFiltersBtn = document.getElementById("toggleFiltersBtn");
    const filtersPanel = document.getElementById("filtersPanel");
    const confettiCanvas = document.getElementById("confettiCanvas");
    const confettiCtx = confettiCanvas.getContext("2d");

    function resizeConfettiCanvas() {
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
    }
    resizeConfettiCanvas();
    window.addEventListener("resize", resizeConfettiCanvas);

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function getInactiveCategories() {
      const inputs = document.querySelectorAll('input[name="categoryFilter"]');
      const inactive = [];
      inputs.forEach(input => {
        if (!input.checked) inactive.push(input.value);
      });
      return inactive;
    }

    function updateStatus(message = "") {
      const remaining = deck.length;
      const discarded = discardPile.length;
      const info = `Cards remaining: ${remaining} • Discard pile: ${discarded}`;
      statusEl.textContent = message ? `${message}  ${info}` : info;
    }

    function isSpecialCard(card) {
      if (!card) return false;
      const isMiniGame = (card.type === "miniGame");
      const cats = Array.isArray(card.categories) ? card.categories : [];
      const isSuperCategory = cats.includes("super");
      const name = typeof card.name === "string" ? card.name : "";
      const isSuperName = name.startsWith("Super Modifier");
      return isMiniGame || isSuperCategory || isSuperName;
    }

    function buildDeck(showMessage = true) {
      if (!fullCards.length) {
        statusEl.textContent = "Deck is still loading...";
        return;
      }

      const inactiveCats = getInactiveCategories();
      let source = fullCards.filter(card =>
        !inactiveCats.length ||
        card.categories.every(cat => !inactiveCats.includes(cat))
      );

      deck = [];
      discardPile = [];

      if (!source.length) {
        statusEl.textContent = "No cards match the current filters. Adjust filters to rebuild the deck.";
        return;
      }

      const specials = source.filter(isSpecialCard);
      const normals = source.filter(card => !isSpecialCard(card));

      // If there are no normals, spacing rules are impossible; just shuffle.
      if (!normals.length || !specials.length) {
        deck = [...source];
        shuffleArray(deck);
        if (showMessage) updateStatus("Deck shuffled. Ready to draw.");
        else updateStatus();
        return;
      }

      shuffleArray(specials);
      shuffleArray(normals);

      let ordered = [];

      // First card must be a normal card
      ordered.push(normals.pop());

      // Case 1: specials <= normals → we can strictly alternate S,N,S,N...
      if (specials.length <= normals.length) {
        while (normals.length || specials.length) {
          if (specials.length) {
            ordered.push(specials.pop());
          }
          if (normals.length) {
            ordered.push(normals.pop());
          }
        }
      } else {
        // Case 2: more specials than normals → best-effort spacing, no warnings
        let lastWasSpecial = false;
        while (normals.length || specials.length) {
          if (!lastWasSpecial && specials.length && (normals.length === 0 || Math.random() < 0.5)) {
            ordered.push(specials.pop());
            lastWasSpecial = true;
          } else if (normals.length) {
            ordered.push(normals.pop());
            lastWasSpecial = false;
          } else {
            // Only specials left; may get consecutive specials, which is fine in extreme filters
            ordered.push(specials.pop());
            lastWasSpecial = true;
          }
        }
      }

      // We draw from deck.pop(), so reverse so the "first" card is at the end
      deck = ordered.reverse();

      if (showMessage) updateStatus("Deck shuffled. Ready to draw.");
      else updateStatus();
    }

    function drawCard() {
      if (!deck.length) {
        updateStatus("The deck is empty. Tap Shuffle Deck to start a new cycle.");
        return;
      }
      const card = deck.pop();
      discardPile.push(card);
      showCard(card);
      updateStatus();
    }

    let confettiParticles = [];
    let confettiAnimating = false;

    function launchConfetti() {
      const count = 80;
      const colors = ["#ffcc00", "#ff6ec7", "#00f5d4", "#9b5bff", "#ff9a62", "#ffffff"];

      confettiParticles = [];
      for (let i = 0; i < count; i++) {
        confettiParticles.push({
          x: Math.random() * confettiCanvas.width,
          y: -10 - Math.random() * 40,
          radius: 3 + Math.random() * 4,
          color: colors[Math.floor(Math.random() * colors.length)],
          vx: -2 + Math.random() * 4,
          vy: 2 + Math.random() * 3,
          rotation: Math.random() * Math.PI * 2,
          vr: -0.2 + Math.random() * 0.4
        });
      }

      if (!confettiAnimating) {
        confettiAnimating = true;
        const start = performance.now();

        function frame(now) {
          const elapsed = now - start;
          confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

          confettiParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05;
            p.rotation += p.vr;

            confettiCtx.save();
            confettiCtx.translate(p.x, p.y);
            confettiCtx.rotate(p.rotation);
            confettiCtx.fillStyle = p.color;
            confettiCtx.beginPath();
            confettiCtx.ellipse(0, 0, p.radius, p.radius * 0.6, 0, 0, Math.PI * 2);
            confettiCtx.fill();
            confettiCtx.restore();
          });

          if (elapsed < 1500) {
            requestAnimationFrame(frame);
          } else {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            confettiAnimating = false;
          }
        }

        requestAnimationFrame(frame);
      }
    }

    function animateShuffle() {
      if (!window.gsap) return;
      gsap.fromTo(
        cardEl,
        { rotationZ: -3 },
        {
          rotationZ: 3,
          duration: 0.08,
          repeat: 5,
          yoyo: true,
          ease: "sine.inOut",
          onComplete() {
            gsap.to(cardEl, { rotationZ: 0, duration: 0.1 });
          }
        }
      );
    }

    function applyCardStylesAndText(card) {
      cardEl.classList.remove("mini-game", "super-modifier", "chaos-glow");

      const special = isSpecialCard(card);
      const isMiniGame = (card.type === "miniGame");
      const name = typeof card.name === "string" ? card.name : "";
      const isSuper = name.startsWith("Super Modifier") ||
        (Array.isArray(card.categories) && card.categories.includes("super"));

      if (isMiniGame) {
        cardEl.classList.add("mini-game");
      } else if (isSuper) {
        cardEl.classList.add("super-modifier");
      }

      if (isMiniGame) {
        cardTypeLabel.textContent = "Mini Game";
      } else if (isSuper) {
        cardTypeLabel.textContent = "Super Modifier";
      } else {
        cardTypeLabel.textContent = "Shared Modifier";
      }

      cardTitleEl.textContent = card.name || "(Unnamed card)";
      cardTextEl.textContent = card.text || "";

      if (special) {
        cardEl.classList.add("chaos-glow");
        launchConfetti();
      }
    }

    function showCard(card) {
      if (window.gsap) {
        gsap.to(cardEl, {
          duration: 0.2,
          rotationY: 90,
          ease: "power1.in",
          onComplete() {
            applyCardStylesAndText(card);
            gsap.fromTo(
              cardEl,
              { rotationY: -90, scale: 0.96, opacity: 0.9 },
              {
                rotationY: 0,
                scale: 1,
                opacity: 1,
                duration: 0.32,
                ease: "back.out(1.6)"
              }
            );
          }
        });
      } else {
        cardEl.classList.remove("draw-anim");
        void cardEl.offsetWidth;
        cardEl.classList.add("draw-anim");
        applyCardStylesAndText(card);
      }
    }

    function parseCsv(text) {
      const rows = [];
      let row = [];
      let cell = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];

        if (inQuotes) {
          if (ch === '"') {
            if (text[i + 1] === '"') {
              cell += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            cell += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === ",") {
            row.push(cell);
            cell = "";
          } else if (ch === "\n") {
            row.push(cell);
            rows.push(row);
            row = [];
            cell = "";
          } else if (ch === "\r") {
            // ignore
          } else {
            cell += ch;
          }
        }
      }

      if (cell !== "" || row.length) {
        row.push(cell);
        rows.push(row);
      }

      return rows;
    }

    async function loadCardsFromSheet() {
      statusEl.textContent = "Loading deck from sheet...";
      deck = [];
      discardPile = [];
      try {
        const res = await fetch(SHEET_CSV_URL);
        if (!res.ok) throw new Error("Network error");
        const text = await res.text();
        const rows = parseCsv(text);
        if (!rows.length) {
          statusEl.textContent = "No data found in sheet.";
          return;
        }

        const header = rows[0].map(h => h.trim().toLowerCase());
        const nameIdx = header.indexOf("name");
        const typeIdx = header.indexOf("type");
        const catIdx = header.indexOf("categories");
        const textIdx = header.indexOf("text");

        const cards = [];
        for (let i = 1; i < rows.length; i++) {
          const r = rows[i];
          if (!r || r.every(c => !c || !c.trim())) continue;

          const rawName = (r[nameIdx] || "").trim();
          const rawType = (r[typeIdx] || "modifier").trim();
          const rawCats = (r[catIdx] || "").trim();
          const rawText = (r[textIdx] || "").trim();

          const type = rawType.toLowerCase() === "minigame" ? "miniGame" : "modifier";

          let categories = rawCats
            ? rawCats.split(/[;|]/).map(c => c.trim()).filter(Boolean)
            : [];

          if (rawName.startsWith("Super Modifier") && !categories.includes("super")) {
            categories.push("super");
          }

          cards.push({
            name: rawName,
            type,
            categories,
            text: rawText
          });
        }

        fullCards = cards;
        buildDeck(false);
        updateStatus("Deck loaded. Ready to draw.");
      } catch (err) {
        console.error("Error loading sheet", err);
        statusEl.textContent = "Could not load deck from sheet.";
      }
    }

    drawButton.addEventListener("click", drawCard);
    shuffleButton.addEventListener("click", () => {
      animateShuffle();
      buildDeck();
    });
    cardEl.addEventListener("click", drawCard);

    toggleFiltersBtn.addEventListener("click", () => {
      filtersPanel.classList.toggle("open");
    });

    document.querySelectorAll('input[name="categoryFilter"]').forEach(input => {
      input.addEventListener("change", () => {
        buildDeck(false);
      });
    });

    loadCardsFromSheet();
  </script>
</body>
</html>
